// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package FlatGeobuf

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type GeometryT struct {
	Ends []uint32
	Xy []float64
	Z []float64
	M []float64
	T []float64
	Tm []uint64
	Type GeometryType
	Parts []*GeometryT
}

func (t *GeometryT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	endsOffset := flatbuffers.UOffsetT(0)
	if t.Ends != nil {
		endsLength := len(t.Ends)
		GeometryStartEndsVector(builder, endsLength)
		for j := endsLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.Ends[j])
		}
		endsOffset = builder.EndVector(endsLength)
	}
	xyOffset := flatbuffers.UOffsetT(0)
	if t.Xy != nil {
		xyLength := len(t.Xy)
		GeometryStartXyVector(builder, xyLength)
		for j := xyLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.Xy[j])
		}
		xyOffset = builder.EndVector(xyLength)
	}
	zOffset := flatbuffers.UOffsetT(0)
	if t.Z != nil {
		zLength := len(t.Z)
		GeometryStartZVector(builder, zLength)
		for j := zLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.Z[j])
		}
		zOffset = builder.EndVector(zLength)
	}
	mOffset := flatbuffers.UOffsetT(0)
	if t.M != nil {
		mLength := len(t.M)
		GeometryStartMVector(builder, mLength)
		for j := mLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.M[j])
		}
		mOffset = builder.EndVector(mLength)
	}
	tOffset := flatbuffers.UOffsetT(0)
	if t.T != nil {
		tLength := len(t.T)
		GeometryStartTVector(builder, tLength)
		for j := tLength - 1; j >= 0; j-- {
			builder.PrependFloat64(t.T[j])
		}
		tOffset = builder.EndVector(tLength)
	}
	tmOffset := flatbuffers.UOffsetT(0)
	if t.Tm != nil {
		tmLength := len(t.Tm)
		GeometryStartTmVector(builder, tmLength)
		for j := tmLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.Tm[j])
		}
		tmOffset = builder.EndVector(tmLength)
	}
	partsOffset := flatbuffers.UOffsetT(0)
	if t.Parts != nil {
		partsLength := len(t.Parts)
		partsOffsets := make([]flatbuffers.UOffsetT, partsLength)
		for j := 0; j < partsLength; j++ {
			partsOffsets[j] = t.Parts[j].Pack(builder)
		}
		GeometryStartPartsVector(builder, partsLength)
		for j := partsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(partsOffsets[j])
		}
		partsOffset = builder.EndVector(partsLength)
	}
	GeometryStart(builder)
	GeometryAddEnds(builder, endsOffset)
	GeometryAddXy(builder, xyOffset)
	GeometryAddZ(builder, zOffset)
	GeometryAddM(builder, mOffset)
	GeometryAddT(builder, tOffset)
	GeometryAddTm(builder, tmOffset)
	GeometryAddType(builder, t.Type)
	GeometryAddParts(builder, partsOffset)
	return GeometryEnd(builder)
}

func (rcv *Geometry) UnPackTo(t *GeometryT) {
	endsLength := rcv.EndsLength()
	t.Ends = make([]uint32, endsLength)
	for j := 0; j < endsLength; j++ {
		t.Ends[j] = rcv.Ends(j)
	}
	xyLength := rcv.XyLength()
	t.Xy = make([]float64, xyLength)
	for j := 0; j < xyLength; j++ {
		t.Xy[j] = rcv.Xy(j)
	}
	zLength := rcv.ZLength()
	t.Z = make([]float64, zLength)
	for j := 0; j < zLength; j++ {
		t.Z[j] = rcv.Z(j)
	}
	mLength := rcv.MLength()
	t.M = make([]float64, mLength)
	for j := 0; j < mLength; j++ {
		t.M[j] = rcv.M(j)
	}
	tLength := rcv.TLength()
	t.T = make([]float64, tLength)
	for j := 0; j < tLength; j++ {
		t.T[j] = rcv.T(j)
	}
	tmLength := rcv.TmLength()
	t.Tm = make([]uint64, tmLength)
	for j := 0; j < tmLength; j++ {
		t.Tm[j] = rcv.Tm(j)
	}
	t.Type = rcv.Type()
	partsLength := rcv.PartsLength()
	t.Parts = make([]*GeometryT, partsLength)
	for j := 0; j < partsLength; j++ {
		x := Geometry{}
		rcv.Parts(&x, j)
		t.Parts[j] = x.UnPack()
	}
}

func (rcv *Geometry) UnPack() *GeometryT {
	if rcv == nil { return nil }
	t := &GeometryT{}
	rcv.UnPackTo(t)
	return t
}

type Geometry struct {
	_tab flatbuffers.Table
}

func GetRootAsGeometry(buf []byte, offset flatbuffers.UOffsetT) *Geometry {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Geometry{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Geometry) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Geometry) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Geometry) Ends(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *Geometry) EndsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Geometry) MutateEnds(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *Geometry) Xy(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Geometry) XyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Geometry) MutateXy(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Geometry) Z(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Geometry) ZLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Geometry) MutateZ(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Geometry) M(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Geometry) MLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Geometry) MutateM(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Geometry) T(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Geometry) TLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Geometry) MutateT(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Geometry) Tm(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *Geometry) TmLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Geometry) MutateTm(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *Geometry) Type() GeometryType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return GeometryType(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Geometry) MutateType(n GeometryType) bool {
	return rcv._tab.MutateByteSlot(16, byte(n))
}

func (rcv *Geometry) Parts(obj *Geometry, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Geometry) PartsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GeometryStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func GeometryAddEnds(builder *flatbuffers.Builder, ends flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ends), 0)
}
func GeometryStartEndsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GeometryAddXy(builder *flatbuffers.Builder, xy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(xy), 0)
}
func GeometryStartXyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func GeometryAddZ(builder *flatbuffers.Builder, z flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(z), 0)
}
func GeometryStartZVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func GeometryAddM(builder *flatbuffers.Builder, m flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(m), 0)
}
func GeometryStartMVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func GeometryAddT(builder *flatbuffers.Builder, t flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(t), 0)
}
func GeometryStartTVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func GeometryAddTm(builder *flatbuffers.Builder, tm flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(tm), 0)
}
func GeometryStartTmVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func GeometryAddType(builder *flatbuffers.Builder, type_ GeometryType) {
	builder.PrependByteSlot(6, byte(type_), 0)
}
func GeometryAddParts(builder *flatbuffers.Builder, parts flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(parts), 0)
}
func GeometryStartPartsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GeometryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
